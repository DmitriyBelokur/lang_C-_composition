# Состав языка
## Алфавит
В отличие от низкоуровнего языка программрования, типа Assembler, высокоуровневый язык программирования подобен человеческом узыку. Т.е. он ближе для нашего понимания, чем низкоуровневый язык.
```cpp
#пример простейшей программы на C++
#include <stdio.h>
// g++ basic_program.cpp -o basic_program
int main(int argc, char const *argv[])
{
  printf("First program \n");
  return 0;
}
```
```assembly
#пример простейшей программы на asm
	.file	"basic_program.cpp"
	.intel_syntax noprefix
	.section	.rodata
.LC0:
	.string	"First program "
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	push	rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	mov	rbp, rsp
	.cfi_def_cfa_register 6
	sub	rsp, 16
	mov	DWORD PTR [rbp-4], edi
	mov	QWORD PTR [rbp-16], rsi
	mov	edi, OFFSET FLAT:.LC0
	call	puts
	mov	eax, 0
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.10) 5.4.0 20160609"
	.section	.note.GNU-stack,"",@progbits
```
Как видно из выше приведенных примеров программа на С++ более человеко читаемая чем таже прогрмма на assembly.
Основу языка С++ как в человеческом языке составляют символы, слова, предложения. Но в отличие от человеческого язык программирования подчиняется жестким правилам, т.е. немного проще. Это обусловлено тем что компьютер обрабатывает только заданный набор команд.
Алфавит языка С++ составляют символы, которые являються частью таблицы ASCII, и которые допустимые в данном языке:
- прописыне и строчные буквы (A,B,C,a,c, и т.д.)
- цифры
- специальные символы(операторы) + -/ % . ? ! " > | \ ' _ & ~ 
- символы пунктуации [] () {} , ; : ... * = # (Пунктуаторы в C ++ имеют синтаксическое и семантическое значение для компилятора, но сами по себе не определяют операцию, которая возвращает значение.)
- пробельные символы: пробел, символ табуляции, символ перевода строки
- прочие символы — только в комментариях к тексту программы

Также в С++ выделяют альтернативные ключевые слова, и диграфы, правда их применение очень редкое. Они были включены в язык в силу того что некоторые системы с клавиатурами и дисплеями не могли работать с символами которые есть частью синтаксиса С++, т.е. ISO 646 стандарт, в который были включены алфавит языка, не имел всех символов.

https://en.cppreference.com/w/cpp/language/operator_alternative

Символы алфавита образуют лексемы.

### Лексемы
Лексема это найменшая единица языка, которая имеет значение для компилятора.
Выделяют следующие лексемы:
- идентификаторы
- ключевые слова
- литералы
- операторы
- знак пунктуации
- и другие разделители

Набор таких лексем, образуют модуль трасляции (translation unit). Обычно токены разделены пробелами, почему обычно так как парсер С++ или компилятор пытается сформировать семантику с лексем.
```cpp
int a = 10;
int b = 20;
. . .
int res = a+++++b; // (a++) + (++b)
```
Иногда выделяют лексемы препроцессора (дериктивы препроцессора), а иногда их относят к ключевым словам (#include, #define, #if_def, и т.д.)

### Идентификатор
Идентификатор - это имя обьекта (сущности). В программировании с помощью идентификатора придают некий смысл обьекту на который можно сослаться, т.е дают уникальный признак обьекта. Индентификаторами в языке С++ обозначают имена переменных, функций, классы, массивы и т.д. Т.е. как видно с описания индентификатор это важная составляющая, которя позволяет именовать важные обьекты необходимые при работе программы. Стоит отметить что уникальность в большей части связана с модулем трансляции(т.е. областью виимости). С++ выделяет следующие правила для именования идентификаторов:
- индетификатор это последовальность символов определенной длины (тут все зависит от компилятора), которая состоит из букв верхнего и нижнего регистра, символа подчеркивания и цифр
- пробелы и другие специальные символы в именовании переменных запрещены(+, - и т.д.)
- идентификаторы должны начинаться с символа подчеркивания или буквы
- имена индентификаторов чуствительны к регистру (т.е. имя variable и Variable это разные имена)
- именем индетификатора не может быть одно из ключевых слов(зарезервированным именем)
- каждый индентификатор содержащий двойное подчеркивание или начинающийся с подчеркивания за которым следует заглавная буква зарезервировано, любое имя начинающееся с нижнего подчеркивания зарезервировано для использования для имен с глобального пространства имен. Т.е. имена начинающиеся с одного или двох символов нижнего подчеркивания зарезервированы для использования языком С++(чаще символы имена с нижним подчеркиваниям могут быть расширением компилятора)

Имя индентификатора должно быть самоописвающим, т.е. должно нести смысл что скрывается за этим именем. Например, если это функция, то в имени функции должно быть указано что делает функция, но это все условность, чаще имена придумываю для лучшего чтения кода, как самим собой спустя некоторое время или другими людьми. Чаще при назначении имени идентификатора придерживаются некоторго codestyle(например google code style)

### Ключевые слова
Ключевое слово это индетификатор специального назначения, т.е. зарезервирован языком. Когда компилятор встречает ключевое слово он подразумевает специальную функциональность. Например если он встретил for он подразумевает что следует начало цыкла, и строит вокруг семантику или правило которое должно подразумевать цыкл for до окончания инструкции. Ключевые слова не могу использоватся в качестве имени идентификатора.
Ниже приведена ссылка описывающая ключеве слова
https://en.cppreference.com/w/cpp/keyword

### Коментарии
Коментарии в программе являються важной составляющей языка, т.к. с помощью коментариев вы описываете интерфейсы ваших функций или классов, даете краткое обьяснение сложной математической инструкции или описания алгоритма. Коментарии можно писать на любом языке и вставлять любые символы, ссылки на url страницы, т.к. коментарии являються частью исходного кода, т.е. компилятор их игнорирует, и они предназначены для удобства чтения кода. Надо отметить что писать много коментариев это плохой подход, надо стремится так что бы имена переменых или функций несли смысл что они делают, т.е. быть самодокументируемыми. В языке С++ существует два вида коментариев многострочный и однострочные

#### Многострочные коментарии
Многострочные коментарии начинаються с символа `\*` и заканчиваються символом `*\`, все что находятся между ними игнорируется. Чаще между символами открытия и закрытия многострочных коментариев вставляют символ звездочка `*` для более удобного документирования.
```cpp
/*Много
строчный
коментарий*/

/**
 * Более удобный многострочный коментарий
 */

```
Чаще многострочные коментарии используют для описания интерфейсов в программе, т.е. например функции, что она делает что есть входными параметрами и что возвращает функция. Или друой вариант это описания сложного алгоритма, для которого необходимо пояснения.
Надо отметить что многострочные коментарии используют так называемые системы генирации документации, например Doxygen
```cpp
/**
 * @brief check is a file exists
 * @param file_name name of the file
 * @return TRUE if file is present othewise FALSE
 */
bool IsFileExists(const char* file_name);
```

#### Однострочные коментарии
Однострочные коментарии начинаються с двух символов обратной черты `\\`, и служат для быстрого обьяснения одной инструкции, т.е. строки кода. Иногда с помощью однострочных коментариев пишут так называемые в програмировании TODO:, т.е. пишут что надо сделать, или чего нехватает в этом участке кода(функции).
```cpp
// Однострочный коментарий
// TODO: эту функцию необходимо отрефакторить
```

### Литералы
Это фиксированное значение которое записано прямо в исходном коде(иными словами это константа). Чаще литералы применяються для примитивных типов(т.е. встроенных)
В С++ выделяют следующие типы литералов
- Целочисленные
- Вещественные
- Логические
- Указательные (начиная с C++11)
- Бинарные (начиная с С++14)
- Символьные
- Строковые

#### Целочисленные
Целочисленный литерал нчинается с цифры и не имеет дробной части. Также целочисленный литерал можно представить в десятичном, шестнадцетиричной или восмеричной формах.
```cpp
5 // целочисленный литерал в десятичной форме
099 // целочисленный литерал в восьмеричной форме
0xFF // целочисленный литерал в шестнадцетиричной форме
```
Как видно с вышеприведенных примеров восьмеричный литерал начинается всегда с нуля, и это частая ошибка. А шестнадцетиричная форма начинается с символа 0 за которым следует символ икс(регистр также не имеет значения), также стоить заметить что символы шестнадцетиричного представления не регистрозависимые, т.е. `0xFF`, `0xff` и `0Хff` это одно и тоже.
Начиная с С++14 добавили так называемый цифровой разделитель
```cpp
1'000'000 // до С++14 это была ошибка компиляции
```

#### Вещественные
Вещественный литерал имеет целую часть, десятичную точку, дробную часть и экспонинцеальную часть. При добавлении экспонентной части пишут символ `e` или `E` что одно и тоже с последующим необьязательным знаком (+ или -).
```cpp
// представления вещественного числа без экпонинцеальной части
1.25
1.
```
```cpp
// представления вещественного числа c экпонинцеальной частью
1.25e0 // 1.25
1.25e1 // 12.5
1.25e-1 // 0.125
```
#### Логические
Логические литералы бывают двух видов `true` или `false`. На саммом деле булевы литералы преобразуются в целочисленный литералы `1` и `0` соответсвенно.

#### Указательные
С++11 ввел новый литерал nullptr, который применяется для инициализации указателей.

#### Бинарные
Начиная С++11 в языке появилась новая возможность определять бинарные литералы для работы с бинарной арифметикой. Бинарные литералы начинаються с префикса `0b` или `0B`, и состоят с ноликов и единиц. Бинарные литералы также можно отнести и целочисленным литералам.

#### Символьные
Сивольные литералы заключаються в одинарные кавычки. Чаще симвльные литералы используют для так назваемых escape последовательностей(или управляющие символы)
```cpp
'\n'
'\t'
'\0'
```

#### Строковые
Строковые литералы иммею важную составляющую в программировании. Строковый литерал это обычная последовательность символов заключенная в двойные кавычки.
```cpp
"this string literal"
```
Чаще строковый литерал представляют в UTF-8 кодировке, т.е. таблице ASCII. Т.е. размер символа помещаеться в один байт. Но иногда используют Unicode кодировку где размер соотвтсвенно 2 бйта.
Важной отличием строкового литерала от других литералов, то что строковый литерал чаще всего хранится в так называемой памяти сегмента данных, тогда как целочисленные литералы встраиваються непосредственно в машинные инструкции.
```cpp
#include <stdio.h>
int main(int argc, char const *argv[])
{
  printf("Integer value %d", 10);
  return 0;
}

// этот код на языке assembler
	.file	"basic_program.cpp"
	.section	.rodata
.LC0:
	.string	"Integer value %d" ; строковый литерал
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$16, %rsp
	movl	%edi, -4(%rbp)
	movq	%rsi, -16(%rbp)
	movl	$10, %esi          ; целочисленный литерал встраивается непосредственно в регистр
	movl	$.LC0, %edi
	movl	$0, %eax
	call	printf
	movl	$0, %eax
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
```
Начиная с С++11 появилась возможность писать так называемые сырые строки, т.е. строка пердставлеться так как мы ее записали, без escape последовательностей
```cpp
R"(one line
new line start)"
// до С++11 необходимо было записать следующее
"one line \nnew line start"
```
Сырые литералы чаще применяют применяют при написании регярных выражений

Ниже приведен пример демонстрирующий вывод литералов на консоль
```cpp
#include <stdio.h>
#include <iostream>
// g++ -Wall -std=c++1y literals.cpp -o literals
int main(int argc, char const *argv[])
{
  printf("This is integer literal %d\n", 10);
  printf("This is integer literal in hex format 0xA =  %d\n", 0xA);
  printf("This is integer literal represent in octal format %o\n", 10);
  printf("This is float literal %f\n", 1.25);
  printf("This is float literal %f\n", 1.25e1);
  printf("This is char literal %c\n", 'c');
  printf("This is string literal %s\n", "string");

  std::cout << std::boolalpha;
  std::cout << true << " " << false << std::endl;
  return 0;
}
```

```
// Output
This is integer literal 10
This is integer literal in hex format 0xA =  10
This is integer literal represent in octal format 12
This is float literal 1.250000
This is float literal 12.500000
This is char literal c
This is string literal string
true false
```

### Инструкция
Инструкция это некоторое утверждения, которое говорит компилятору выполнить некоторое дейсвие. Инструкции завершаються точкой с запятой. Инструкции обычно выполняються последовательно как они всречаються в программе, почему обычно т.к. иногда компилятор делает перестановку инструкций. Есть однострочные инструкции или составные.
```cpp
// пример однострочной инструкции
int a; // инструкция обьявление переменной
a = 10; // инструкция присвоения переменной целочисленного значения
```
Составные инструкции чаще называют блоками
```cpp
// пример составной инструкции
if (a > 5) { // составная инструкция, если значение переменной больше 5 то выполнить групу инструкций
  a = 20;
  printf("Value a is %d", a);
}
```
Более подробный список инструкций https://en.cppreference.com/w/cpp/language/statements

### Синтаксис или семантика
Синстаксис определяет правило языка программирования, т.е. правило написания инструкции. Если мы написали неправильно инструкцию, которая противоречит правилам языка то мы получим так называемую ошибку компилятора, т.е. синтаксическая ошибка. При получении синтаксической ошибки сборка программы прекращаеться. Есть другой вид вывода информации от компилятора, т.к. называемые предпреждения, которая просто информирует о возможной сематической ошибке, но не прекращает сборку приложения.
```cpp
#include <stdio.h>
int main(int argc, char const *argv[])
{
  i = 20;
  return 0;
}
```
Если попытаться собрать выше приведенную программу, то мы получим ошибку компиляции, что мы пытаемся присвоить значение переменной которая не была обьявлена.

Следующий тип ошибки так называемая семантическая ошибка, т.е. ошибка логики программы когда програма или ее функциональность выдает не тот результат который ожидается. Считается предпочтительно получить синтаксическую ошибку в отличии от семантической. Чаще симентическую ошибки пытаются выявить на этапе тесттрования или покрытия тестами.
