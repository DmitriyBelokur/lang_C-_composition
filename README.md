# Состав языка
## Алфавит
В отличие от ,например языка Assembler, язык С++ более читабелен, т.е. он ближе для нашего понимания и восприятия. Ниже пример простой программы на С++ печатающая на консоль текстовое сообщение, а следом идет программа на Assembler которая делает то же самое что и программа на языке С++.
```cpp
// пример простейшей программы на С++
/*
 подключаем в нашу программу библиотечный файл
 для того чтобы использовать std::cout
*/
#include <iostream>
// g++ basic_program.cpp -o basic_program
int main(int argc, char const *argv[])
{
  // печатаем на консоль сообщение
  std::cout << "First program \n";
  return 0;
}

```
```assembly
#пример простейшей программы на asm
.LC0:
        .string "First program \n"
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
        mov     DWORD PTR [rbp-4], edi
        mov     QWORD PTR [rbp-16], rsi
        mov     esi, OFFSET FLAT:.LC0
        mov     edi, OFFSET FLAT:_ZSt4cout
        call    std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*)
        mov     eax, 0
        leave
        ret
__static_initialization_and_destruction_0(int, int):
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
        mov     DWORD PTR [rbp-4], edi
        mov     DWORD PTR [rbp-8], esi
        cmp     DWORD PTR [rbp-4], 1
        jne     .L5
        cmp     DWORD PTR [rbp-8], 65535
        jne     .L5
        mov     edi, OFFSET FLAT:_ZStL8__ioinit
        call    std::ios_base::Init::Init() [complete object constructor]
        mov     edx, OFFSET FLAT:__dso_handle
        mov     esi, OFFSET FLAT:_ZStL8__ioinit
        mov     edi, OFFSET FLAT:_ZNSt8ios_base4InitD1Ev
        call    __cxa_atexit
.L5:
        nop
        leave
        ret
_GLOBAL__sub_I_main:
        push    rbp
        mov     rbp, rsp
        mov     esi, 65535
        mov     edi, 1
        call    __static_initialization_and_destruction_0(int, int)
        pop     rbp
        ret
```
Как видно из выше приведенных примеров программа на С++ более читаемая чем таже программа на assembly.
Алфавит языка С++ составляют символы, которые состоят с лексем(слова в нашем понимании), а те в свою очередь составляют инструкции(предложения в нашем понимании). Символы алфавита языка С++ являються частью таблицы ASCII. Существуют следующие допустимые символы в языке С++:
- прописыне и строчные буквы (A,B,C,a,c, и т.д.)
- цифры
- специальные символы(операторы) + -/ % . ? ! " > | \ ' _ & ~ 
- символы пунктуации [] () {} , ; : ... * = # (Пунктуаторы в C ++ имеют синтаксическое и семантическое значение для компилятора, но сами по себе не определяют операцию, которая возвращает значение.)
- пробельные символы: пробел, символ табуляции, символ перевода строки
- прочие символы — только в комментариях к тексту программы

Символы алфавита образуют лексемы.

### Лексемы
Лексема это найменшая единица языка, которая обрабатывает специальная программа компилятор, и из набора лексем формирует законченную инструкцию.
Выделяют следующие лексемы:
- идентификаторы
- ключевые слова
- литералы
- операторы
- знак пунктуации
- и другие разделители

Набор таких лексем, образуют модуль трасляции (translation unit, файл с расширением cpp). Обычно  лексемы разделены пробелами, почему обычно так как парсер С++ или компилятор пытается сформировать семантику с лексем. Например построить инструкцию для выполнения. Ниже пример который не будет компилироваться компилятором, так симантически не коректен
```cpp
int a = 10;
int b = 20;
. . .
int res = a+++++b; // было бы правильно если мы написали на подобии такого (a++) + (++b)
```
Также существуют лексемы препроцессора (дериктивы препроцессора) (#include, #define, #if_def, и т.д.).

### Идентификатор
Идентификатор - это некая идетифицируемая сущность(или можно сказать имя назначаемое элементу кода). В программировании с помощью идентификатора придают некий смысл сущности, указавая например ее назначение или функциональность. Индентификаторами в языке С++ обозначают имена переменных, функций, классов, и т.д. Т.е. как видно с описания индентификатор это важная составляющая, которя позволяет именовать важные сущности необходимые при работе программы. Важно то что в с++ существуют следующие правила для правильного именования идентификаторов:
- индетификатор это последовальность символов определенной длины (тут все зависит от компилятора), которая состоит из букв верхнего и нижнего регистра, символа подчеркивания и цифр
- пробелы и другие специальные символы в именовании переменных запрещены(+, - и т.д.)
- идентификаторы должны начинаться с символа подчеркивания или буквы
- имена индентификаторов чуствительны к регистру (т.е. имя variable и Variable это разные имена)
- именем индетификатора не может быть одно из ключевых слов(зарезервированным именем)
- каждый индентификатор содержащий двойное подчеркивание или начинающийся с подчеркивания за которым следует заглавная буква зарезервировано, любое имя начинающееся с нижнего подчеркивания зарезервировано для использования для имен с глобального пространства имен. Т.е. имена начинающиеся с одного или двох символов нижнего подчеркивания зарезервированы для использования языком С++(чаще символы имена с нижним подчеркиваниям могут быть расширением компилятора)

Выше перечисленное это синтаксическая составляющая индетификатора, нарушив ее мы можем получить ошибку компиляции, но существует и что важно логическая составляющая в именовании идентификаторов это то что имя индентификатора должно быть самоописвающим, т.е. должно нести смысл что скрывается за этим именем. Например, если это функция, то в имени функции должно быть указано что делает функция, но это все условность, чаще имена придумываю для лучшего чтения кода, чтобы даже мы могли сами спустя некоторое время прочесть и понять что мы сделали в коде, так и других кодеров. Чаще при назначении имени идентификатора придерживаются некоторго codestyle(например google code style)

### Ключевые слова
Ключевое слово это индетификатор специального назначения, т.е. зарезервирован языком. Когда компилятор встречает ключевое слово он бует выполнять специальную функциональность которое завязано на этом ключевом слове. Например если он встретил for он подразумевает что следует начало цыкла, и строит вокруг синтаксическое и семантическое правило которое должно подразумевать цыкл for до окончания инструкции. Ключевые слова не могу использоватся в качестве имени идентификатора для переменных функцию, и других пользовательских идентификаторов.
Ниже приведена ссылка описывающая ключевые слова
https://en.cppreference.com/w/cpp/keyword

### Коментарии
Коментарии в программе являються одной и з важных составляющей языка, т.к. с помощью коментариев вы описываете интерфейсы ваших функций или классов(т.е. что они делают), даете краткое обьяснение сложной математической инструкции или описания алгоритма. Коментарии можно писать на любом языке и вставлять любые символы, ссылки на url страницы, т.к. компилятор в процессе компиляции исходного кода просто их игнорирует, и они предназначены для удобства чтения кода(т.е. пишуться опять же для нас и других кодеров). Надо отметить что писать коментарии для очевидных вещей это плохой подход, надо стремится так что бы имена переменых или функций несли смысл что они делают, т.е. быть самодокументируемыми. В языке С++ существует два вида коментариев многострочный и однострочные

#### Многострочные коментарии
Многострочные коментарии начинаються с символа `\*` и заканчиваються символом `*\`, все что находятся между ними игнорируется в процессе компиляции. Чаще между символами открытия и закрытия многострочных коментариев вставляют символ звездочка `*` для более удобного документирования.
```cpp
/*Много
строчный
коментарий*/

/**
 * Более удобный многострочный коментарий
 */

```
Чаще многострочные коментарии используют для описания интерфейсов в программе, т.е. например функции, что она делает что есть входными параметрами и что возвращает функция. Или друой вариант это описания сложного алгоритма, для которого необходимо пояснения.
Надо отметить что многострочные коментарии используют так называемые системы генирации документации, например Doxygen
```cpp
/**
 * @brief check is a file exists
 * @param file_name name of the file
 * @return TRUE if file is present othewise FALSE
 */
bool IsFileExists(const char* file_name);
```

#### Однострочные коментарии
Однострочные коментарии начинаються с двух символов обратной черты `\\`, и служат для быстрого обьяснения одной инструкции, т.е. строки кода. Иногда с помощью однострочных коментариев пишут так называемые в програмировании TODO:, т.е. пишут что надо сделать в будущем, или чего нехватает в этом участке кода(функции).
```cpp
// Однострочный коментарий
// TODO: эту функцию необходимо отрефакторить
```

### Литералы
Это фиксированное значение которое не имеет имени, а являеться частью исходного кода программы (иными словами это константа). Чаще литералы применяються для инициализации примитивных типов (т.е. встроенных) или испольуються в арифметических выражениях.
В С++ выделяют следующие типы литералов
- Целочисленные
- Вещественные
- Логические
- Указательные (начиная с C++11)
- Бинарные (начиная с С++14)
- Символьные
- Строковые

#### Целочисленные
Целочисленный литерал нчинается с цифры и не имеет дробной части. Также целочисленный литерал можно представить в десятичном, шестнадцетиричной или восмеричной формах.
```cpp
5 // целочисленный литерал в десятичной форме
099 // целочисленный литерал в восьмеричной форме
0xFF // целочисленный литерал в шестнадцетиричной форме
```
Как видно с вышеприведенных примеров восьмеричный литерал начинается всегда с нуля, и это бывает иногда частая ошибка у тех кто только начинает писать код на С++. А шестнадцетиричная форма начинается с символа 0 за которым следует символ икс(регистр также не имеет значения), также стоить заметить что символы шестнадцетиричного представления не регистрозависимые, т.е. `0xFF`, `0xff` и `0Хff` это одно и тоже.
Начиная с С++14 добавили так называемый цифровой разделитель
```cpp
1'000'000 // до С++14 это была ошибка компиляции
```

#### Вещественные
Вещественный литерал имеет целую часть, десятичную точку, и не обьязательное это дробную часть и экспонинцеальную часть. При добавлении экспонентной части пишут символ `e` или `E` что одно и тоже с последующим необьязательным знаком (+ или -).
```cpp
// представления вещественного числа без экпонинцеальной части
1.25
1.
```
```cpp
// представления вещественного числа c экпонинцеальной частью
1.25e0 // 1.25
1.25e1 // 12.5
1.25e-1 // 0.125
```
#### Логические
Логические литералы бывают двух видов `true` или `false`. Часто во многом коде можно увидеть что логические литералы представляют ввиде целочисленных литералов 1 и 0, но это есть большая ошибка. Надо помнить что в языке С++ логические литералы бывабт только `true` или `false`.

#### Указательные
С++11 ввел новый литерал `nullptr`, который применяется для инициализации указателей. До этого использовали целочисленный литерал 0 и или конструкцию вида `NULL`. Начиная с стандарта С++11 правильным литералом для указателей должен быть только `nullptr`, и некакой другой.

#### Бинарные
Начиная С++11 в языке появилась новая возможность определять бинарные литералы для работы с бинарной арифметикой. Бинарные литералы начинаються с префикса `0b` или `0B`, и состоят с ноликов и единиц. Бинарные литералы также можно отнести и целочисленным литералам.

#### Символьные
Сивольные литералы заключаються в одинарные кавычки. Чаще симвльные литералы используют для так назваемых escape последовательностей(или управляющие символы)
```cpp
'\n'
'\t'
'\0'
'a'
```

#### Строковые
Строковый литерал это обычная последовательность символьных литералов заключенная в двойные кавычки.
```cpp
"this \nstring literal"
```

Начиная с С++11 появилась возможность писать так называемые сырые строки, т.е. строка пердставлеться так как мы ее записали, без escape последовательностей(без явных символов переноса и т.д.)
```cpp
R"(one line
new line start)"
// до С++11 необходимо было записать следующее
"one line \nnew line start"
```
Сырые литералы чаще применяют применяют при написании регярных выражений

Ниже приведен пример демонстрирующий вывод литералов на консоль
```cpp
// подключаем в нашу программу специальные заголовочные файлы,
// для того что бы использовать  printf, std::cout, std::endl
#include <stdio.h>
#include <iostream>
// g++ -Wall -std=c++1y literals.cpp -o literals
int main(int argc, char const *argv[])
{
  // используеться С подход для печати литералов на консоль
  printf("This is integer literal %d\n", 10);
  printf("This is integer literal in hex format 0xA =  %d\n", 0xA);
  printf("This is integer literal represent in octal format %o\n", 10);
  printf("This is float literal %f\n", 1.25);
  printf("This is float literal %f\n", 1.25e1);
  printf("This is char literal %c\n", 'c');
  printf("This is string literal %s\n", "string");

  // используеться С++ подход для печати литералов на консоль
  std::cout << "My first string print to cout" << std::endl;
  std::cout << "Float literal " << 1.25 << std::endl;
  // указываем то что мы хотим выводить на консоль true и false
  // если это не указать то мы получим на консоле 0 и 1
  std::cout << std::boolalpha;
  std::cout << true << " " << false << std::endl;
  return 0;
}
```

```
// Output
This is integer literal 10
This is integer literal in hex format 0xA =  10
This is integer literal represent in octal format 12
This is float literal 1.250000
This is float literal 12.500000
This is char literal c
This is string literal string
true false
```

### Инструкция
Инструкция это некоторое утверждения, которое говорит компилятору выполнить некоторое дейсвие. Инструкции завершаються точкой с запятой. Инструкции обычно выполняються последовательно как они всречаються в программе, почему обычно т.к. иногда компилятор делает перестановку инструкций(некую оптимизацию, считая что эту инструкцию лучше выполнить первой). Есть однострочные инструкции или составные(блочные).
```cpp
// пример однострочной инструкции
int a; // инструкция обьявление переменной
a = 10; // инструкция присвоения переменной целочисленного значения
```
Составные инструкции чаще называют блоками
```cpp
// пример составной инструкции
{ // анонимная составная инструкция
  a = 20;
  std::cout << "Value a is " << a;
}

// составной блок условного оператора if,
// который говорит что если условие истинное то выполняеться группа операторов размещенных в блоке от { до }
if (a > 20) {
  a = 0;
  std::cout << "Value a is " << a;
}
```
Более подробный список инструкций https://en.cppreference.com/w/cpp/language/statements

### Синтаксис или семантика
Синстаксис определяет правило языка программирования, т.е. правило написания инструкции. Если мы написали неправильно инструкцию, которая противоречит правилам языка то мы получим так называемую ошибку компилятора, т.е. синтаксическая ошибка. При получении синтаксической ошибки сборка программы прекращаеться. Есть другой вид вывода информации от компилятора, т.к. называемые предпреждения, которая просто информирует о возможной сематической ошибке, но не прекращает сборку приложения.
```cpp
#include <stdio.h>
int main(int argc, char const *argv[])
{
  i = 20;
  return 0;
}
```
Если попытаться собрать выше приведенную программу, то мы получим ошибку компиляции, что мы пытаемся присвоить значение переменной которая не была обьявлена.
